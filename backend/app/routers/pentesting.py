"""
Pentesting Toolkit Router
Provides API endpoints for security scanning tools (Nmap, Nikto, Dirb)
All endpoints require Firebase authentication and include security validations.
"""

from fastapi import APIRouter, Depends, HTTPException, status, Request, WebSocket, WebSocketDisconnect
from pydantic import BaseModel, Field, validator
from typing import List, Optional
import subprocess
import asyncio
import re
import ipaddress
import logging
from datetime import datetime
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
from app.auth import verify_firebase_token

# Configure logging for pentesting operations
# Set up structured logging with timestamps
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialize rate limiter for pentesting endpoints
limiter = Limiter(key_func=get_remote_address)

router = APIRouter(prefix="/pentest", tags=["pentesting"])


# ============================================================================
# Pydantic Models for Request/Response
# ============================================================================

class TargetValidator:
    """Shared target validation logic for all scan tools"""
    
    @staticmethod
    def validate_target(v: str) -> str:
        """
        Validate target is a valid IP or domain name.
        Rejects private/local IPs for security.
        """
        v = v.strip()
        
        # Check if it's an IP address
        try:
            ip = ipaddress.ip_address(v)
            # Reject private/local IPs
            if ip.is_private or ip.is_loopback or ip.is_link_local or ip.is_reserved:
                raise ValueError(
                    "Private, local, or reserved IP addresses are not allowed for security reasons"
                )
        except ValueError:
            # Not an IP, check if it's a valid domain name
            domain_pattern = re.compile(
                r'^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$'
            )
            if not domain_pattern.match(v):
                raise ValueError(
                    "Target must be a valid IP address or domain name"
                )
        
        return v


class NmapScanRequest(BaseModel):
    """
    Request model for Nmap scan endpoint.
    
    Example:
        {
            "target": "example.com",
            "options": ["-sV", "-p", "80,443"]
        }
    """
    target: str = Field(..., description="Target IP address or domain name")
    options: Optional[List[str]] = Field(
        default_factory=list,
        description="Optional list of Nmap command-line options/flags"
    )

    @validator('target')
    def validate_target(cls, v):
        return TargetValidator.validate_target(v)


class NiktoScanRequest(BaseModel):
    """
    Request model for Nikto web server scanner endpoint.
    
    Example:
        {
            "target": "https://example.com",
            "options": ["-h", "-Display", "V"]
        }
    """
    target: str = Field(..., description="Target URL (e.g., https://example.com)")
    options: Optional[List[str]] = Field(
        default_factory=list,
        description="Optional list of Nikto command-line options/flags"
    )

    @validator('target')
    def validate_target(cls, v):
        # For Nikto, validate URL format
        v = v.strip()
        # Basic URL validation - must start with http:// or https://
        if not (v.startswith('http://') or v.startswith('https://')):
            raise ValueError("Target must be a valid URL starting with http:// or https://")
        # Extract domain/IP for further validation
        url_parts = v.replace('http://', '').replace('https://', '').split('/')[0]
        TargetValidator.validate_target(url_parts)
        return v


class DirbScanRequest(BaseModel):
    """
    Request model for Dirb directory brute-forcer endpoint.
    
    Example:
        {
            "target": "https://example.com",
            "options": ["-w", "-S"]
        }
    """
    target: str = Field(..., description="Target URL (e.g., https://example.com)")
    options: Optional[List[str]] = Field(
        default_factory=list,
        description="Optional list of Dirb command-line options/flags"
    )

    @validator('target')
    def validate_target(cls, v):
        # For Dirb, validate URL format
        v = v.strip()
        # Basic URL validation - must start with http:// or https://
        if not (v.startswith('http://') or v.startswith('https://')):
            raise ValueError("Target must be a valid URL starting with http:// or https://")
        # Extract domain/IP for further validation
        url_parts = v.replace('http://', '').replace('https://', '').split('/')[0]
        TargetValidator.validate_target(url_parts)
        return v


class ScanResponse(BaseModel):
    """Response model for scan operations"""
    success: bool = Field(..., description="Whether the scan completed successfully")
    output: str = Field(..., description="Standard output from the scan tool")
    error: Optional[str] = Field(None, description="Error output if any")
    tool: str = Field(..., description="Name of the tool used")
    target: str = Field(..., description="Target that was scanned")


# ============================================================================
# Security: Allowed Options Whitelists
# ============================================================================

# Whitelist of safe Nmap options to prevent command injection
ALLOWED_NMAP_OPTIONS = {
    '-sS',  # SYN scan
    '-sT',  # TCP connect scan
    '-sU',  # UDP scan
    '-sV',  # Version detection
    '-sC',  # Default script scan
    '-p',   # Port specification (requires value)
    '-Pn',  # Skip host discovery
    '-F',   # Fast scan
    '-T4',  # Timing template
    '-T5',  # Timing template
    '-v',   # Verbose
    '-vv',  # More verbose
    '--version',  # Version info
    '--help',     # Help
}

# Whitelist of safe Nikto options
ALLOWED_NIKTO_OPTIONS = {
    '-h',        # Host
    '-Display',  # Display mode
    '-Format',   # Output format
    '-output',   # Output file (will be ignored, we capture stdout)
    '-port',     # Port
    '-timeout',  # Timeout
    '-useragent', # User agent
    '-C',        # Cookie
    '-Tuning',   # Tuning options
    '-mutate',   # Mutation
    '-Plugins',  # Plugins
    '-Version',  # Version
    '-Help',     # Help
}

# Whitelist of safe Dirb options
ALLOWED_DIRB_OPTIONS = {
    '-w',        # Don't stop on warning messages
    '-N',        # Don't search files with this code
    '-S',        # Silent mode
    '-u',        # Username:password
    '-p',        # Proxy
    '-a',        # Custom user agent
    '-c',        # Cookie
    '-H',        # Custom header
    '-X',        # Don't search files with this extension
    '-z',        # Milliseconds delay
    '-o',        # Output file (will be ignored, we capture stdout)
    '-v',        # Verbose mode
    '-version',  # Version
    '-help',     # Help
}


def sanitize_options(options: List[str], allowed_options: set, tool_name: str) -> List[str]:
    """
    Generic function to sanitize and validate tool options to prevent command injection.
    Only allows whitelisted safe options.
    
    Args:
        options: List of option strings from user input
        allowed_options: Set of allowed option strings
        tool_name: Name of the tool (for error messages)
        
    Returns:
        List of sanitized, validated options
        
    Raises:
        HTTPException: If invalid or dangerous options are detected
    """
    sanitized = []
    
    for opt in options:
        # Remove any whitespace
        opt = opt.strip()
        
        # Skip empty options
        if not opt:
            continue
        
        # Check if option is in whitelist (exact match)
        if opt in allowed_options:
            sanitized.append(opt)
        # Check if option starts with allowed prefix (for options with values)
        elif any(opt.startswith(allowed_opt) for allowed_opt in allowed_options if len(allowed_opt) > 1):
            # Validate that the value part is safe (alphanumeric, dashes, underscores, colons, dots)
            # Extract the option name and value
            for allowed_opt in allowed_options:
                if opt.startswith(allowed_opt):
                    value_part = opt[len(allowed_opt):].strip()
                    # Validate value format - allow alphanumeric, dashes, underscores, colons, dots, commas
                    if re.match(r'^[a-zA-Z0-9\-_.,:/\s]+$', value_part) or not value_part:
                        sanitized.append(opt)
                        break
            else:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Invalid option format: {opt}"
                )
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Option not allowed for security reasons: {opt}. "
                       f"Allowed options for {tool_name}: {', '.join(sorted(allowed_options))}"
            )
    
    return sanitized


def sanitize_nmap_options(options: List[str]) -> List[str]:
    """Sanitize Nmap options"""
    return sanitize_options(options, ALLOWED_NMAP_OPTIONS, "nmap")


def sanitize_nikto_options(options: List[str]) -> List[str]:
    """Sanitize Nikto options"""
    return sanitize_options(options, ALLOWED_NIKTO_OPTIONS, "nikto")


def sanitize_dirb_options(options: List[str]) -> List[str]:
    """Sanitize Dirb options"""
    return sanitize_options(options, ALLOWED_DIRB_OPTIONS, "dirb")


# ============================================================================
# Nmap Scan Endpoint
# ============================================================================

@router.post("/nmap", response_model=ScanResponse, status_code=status.HTTP_200_OK)
@limiter.limit("10/minute")  # Rate limit: 10 requests per minute per IP
async def run_nmap_scan(
    request: Request,
    scan_request: NmapScanRequest,
    user=Depends(verify_firebase_token)
):
    """
    Execute an Nmap network scan against a target.
    
    This endpoint runs Nmap with the specified target and options.
    All scans are logged with user information for security auditing.
    
    **Security Notes:**
    - Only whitelisted Nmap options are allowed
    - Private/local IPs are rejected
    - All requests are logged with user ID and timestamp
    
    **Example Request:**
    ```json
    {
        "target": "example.com",
        "options": ["-sV", "-p", "80,443"]
    }
    ```
    
    **Example Response:**
    ```json
    {
        "success": true,
        "output": "Starting Nmap 7.92...",
        "error": null,
        "tool": "nmap",
        "target": "example.com"
    }
    ```
    
    Args:
        request: FastAPI Request object (for rate limiting)
        scan_request: NmapScanRequest containing target and optional options
        user: Authenticated user from Firebase token (dependency)
        
    Returns:
        ScanResponse with scan results
        
    Raises:
        HTTPException: For validation errors or scan failures
    """
    user_id = user.get("uid", "unknown")
    user_email = user.get("email", "unknown")
    client_ip = get_remote_address(request)
    timestamp = datetime.utcnow().isoformat()
    
    # Enhanced security logging with structured data
    # Log all scan requests with user ID, IP, timestamp for audit trail
    logger.info(
        f"PENTEST_SCAN_REQUEST | "
        f"user_id={user_id} | "
        f"user_email={user_email} | "
        f"client_ip={client_ip} | "
        f"tool=nmap | "
        f"target={scan_request.target} | "
        f"options={scan_request.options} | "
        f"timestamp={timestamp}"
    )
    
    try:
        # Sanitize and validate options
        sanitized_options = sanitize_nmap_options(scan_request.options)
        
        # Build Nmap command
        # Always use absolute path to nmap if possible, or rely on PATH
        cmd = ["nmap"]
        cmd.extend(sanitized_options)
        cmd.append(scan_request.target)
        
        logger.debug(
            f"PENTEST_SCAN_EXEC | user_id={user_id} | "
            f"command={' '.join(cmd)}"
        )
        
        # Execute Nmap using async subprocess for better performance
        # Set timeout to 300 seconds (5 minutes) to prevent hanging
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            text=True
        )
        
        try:
            # Wait for process with timeout
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=300.0
            )
            returncode = process.returncode
        except asyncio.TimeoutError:
            # Kill the process if it times out
            process.kill()
            await process.wait()
            raise subprocess.TimeoutExpired(cmd, 300)
        
        # Create result-like object for compatibility
        class AsyncResult:
            def __init__(self, returncode, stdout, stderr):
                self.returncode = returncode
                self.stdout = stdout
                self.stderr = stderr
        
        result = AsyncResult(returncode, stdout, stderr)
        
        # Enhanced logging for scan completion
        completion_timestamp = datetime.utcnow().isoformat()
        logger.info(
            f"PENTEST_SCAN_COMPLETE | "
            f"user_id={user_id} | "
            f"target={scan_request.target} | "
            f"exit_code={result.returncode} | "
            f"success={result.returncode == 0} | "
            f"timestamp={completion_timestamp}"
        )
        
        # Return response
        return ScanResponse(
            success=result.returncode == 0,
            output=result.stdout,
            error=result.stderr if result.stderr else None,
            tool="nmap",
            target=scan_request.target
        )
        
    except subprocess.TimeoutExpired:
        logger.warning(
            f"PENTEST_SCAN_TIMEOUT | "
            f"user_id={user_id} | "
            f"target={scan_request.target} | "
            f"timestamp={datetime.utcnow().isoformat()}"
        )
        raise HTTPException(
            status_code=status.HTTP_408_REQUEST_TIMEOUT,
            detail="Scan operation timed out after 5 minutes"
        )
    except HTTPException:
        # Re-raise HTTP exceptions (validation errors)
        raise
    except Exception as e:
        logger.error(
            f"PENTEST_SCAN_ERROR | "
            f"user_id={user_id} | "
            f"target={scan_request.target} | "
            f"error={str(e)} | "
            f"timestamp={datetime.utcnow().isoformat()}",
            exc_info=True
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to execute scan: {str(e)}"
        )


# ============================================================================
# Nikto Scan Endpoint
# ============================================================================

@router.post("/nikto", response_model=ScanResponse, status_code=status.HTTP_200_OK)
@limiter.limit("10/minute")  # Rate limit: 10 requests per minute per IP
async def run_nikto_scan(
    request: Request,
    scan_request: NiktoScanRequest,
    user=Depends(verify_firebase_token)
):
    """
    Execute a Nikto web server scan against a target URL.
    
    Nikto is a web server scanner that tests for dangerous files/CGIs,
    outdated server software, and other problems.
    
    **Security Notes:**
    - Only whitelisted Nikto options are allowed
    - Private/local IPs are rejected
    - All requests are logged with user ID and timestamp
    
    **Example Request:**
    ```json
    {
        "target": "https://example.com",
        "options": ["-Display", "V"]
    }
    ```
    
    Args:
        request: FastAPI Request object (for rate limiting)
        scan_request: NiktoScanRequest containing target URL and optional options
        user: Authenticated user from Firebase token (dependency)
        
    Returns:
        ScanResponse with scan results
    """
    user_id = user.get("uid", "unknown")
    user_email = user.get("email", "unknown")
    client_ip = get_remote_address(request)
    timestamp = datetime.utcnow().isoformat()
    
    # Enhanced security logging
    logger.info(
        f"PENTEST_SCAN_REQUEST | "
        f"user_id={user_id} | "
        f"user_email={user_email} | "
        f"client_ip={client_ip} | "
        f"tool=nikto | "
        f"target={scan_request.target} | "
        f"options={scan_request.options} | "
        f"timestamp={timestamp}"
    )
    
    try:
        # Sanitize and validate options
        sanitized_options = sanitize_nikto_options(scan_request.options)
        
        # Build Nikto command
        cmd = ["nikto"]
        cmd.extend(sanitized_options)
        cmd.extend(["-h", scan_request.target])  # Nikto requires -h flag for host
        
        logger.debug(f"PENTEST_SCAN_EXEC | user_id={user_id} | command={' '.join(cmd)}")
        
        # Execute Nikto using async subprocess
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            text=True
        )
        
        try:
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=600.0
            )
            returncode = process.returncode
        except asyncio.TimeoutError:
            process.kill()
            await process.wait()
            raise subprocess.TimeoutExpired(cmd, 600)
        
        class AsyncResult:
            def __init__(self, returncode, stdout, stderr):
                self.returncode = returncode
                self.stdout = stdout
                self.stderr = stderr
        
        result = AsyncResult(returncode, stdout, stderr)
        
        # Log completion
        completion_timestamp = datetime.utcnow().isoformat()
        logger.info(
            f"PENTEST_SCAN_COMPLETE | "
            f"user_id={user_id} | "
            f"target={scan_request.target} | "
            f"exit_code={result.returncode} | "
            f"success={result.returncode == 0} | "
            f"timestamp={completion_timestamp}"
        )
        
        return ScanResponse(
            success=result.returncode == 0,
            output=result.stdout,
            error=result.stderr if result.stderr else None,
            tool="nikto",
            target=scan_request.target
        )
        
    except subprocess.TimeoutExpired:
        logger.warning(
            f"PENTEST_SCAN_TIMEOUT | "
            f"user_id={user_id} | "
            f"target={scan_request.target} | "
            f"timestamp={datetime.utcnow().isoformat()}"
        )
        raise HTTPException(
            status_code=status.HTTP_408_REQUEST_TIMEOUT,
            detail="Scan operation timed out after 10 minutes"
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(
            f"PENTEST_SCAN_ERROR | "
            f"user_id={user_id} | "
            f"target={scan_request.target} | "
            f"error={str(e)} | "
            f"timestamp={datetime.utcnow().isoformat()}",
            exc_info=True
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to execute scan: {str(e)}"
        )


# ============================================================================
# Dirb Scan Endpoint
# ============================================================================

@router.post("/dirb", response_model=ScanResponse, status_code=status.HTTP_200_OK)
@limiter.limit("10/minute")  # Rate limit: 10 requests per minute per IP
async def run_dirb_scan(
    request: Request,
    scan_request: DirbScanRequest,
    user=Depends(verify_firebase_token)
):
    """
    Execute a Dirb directory brute-forcing scan against a target URL.
    
    Dirb is a web content scanner that looks for hidden web objects.
    It works by launching a dictionary-based attack against a web server.
    
    **Security Notes:**
    - Only whitelisted Dirb options are allowed
    - Private/local IPs are rejected
    - All requests are logged with user ID and timestamp
    
    **Example Request:**
    ```json
    {
        "target": "https://example.com",
        "options": ["-w", "-S"]
    }
    ```
    
    Args:
        request: FastAPI Request object (for rate limiting)
        scan_request: DirbScanRequest containing target URL and optional options
        user: Authenticated user from Firebase token (dependency)
        
    Returns:
        ScanResponse with scan results
    """
    user_id = user.get("uid", "unknown")
    user_email = user.get("email", "unknown")
    client_ip = get_remote_address(request)
    timestamp = datetime.utcnow().isoformat()
    
    # Enhanced security logging
    logger.info(
        f"PENTEST_SCAN_REQUEST | "
        f"user_id={user_id} | "
        f"user_email={user_email} | "
        f"client_ip={client_ip} | "
        f"tool=dirb | "
        f"target={scan_request.target} | "
        f"options={scan_request.options} | "
        f"timestamp={timestamp}"
    )
    
    try:
        # Sanitize and validate options
        sanitized_options = sanitize_dirb_options(scan_request.options)
        
        # Build Dirb command
        cmd = ["dirb"]
        cmd.append(scan_request.target)  # Dirb takes URL as first argument
        cmd.extend(sanitized_options)
        
        logger.debug(f"PENTEST_SCAN_EXEC | user_id={user_id} | command={' '.join(cmd)}")
        
        # Execute Dirb using async subprocess
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            text=True
        )
        
        try:
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=600.0
            )
            returncode = process.returncode
        except asyncio.TimeoutError:
            process.kill()
            await process.wait()
            raise subprocess.TimeoutExpired(cmd, 600)
        
        class AsyncResult:
            def __init__(self, returncode, stdout, stderr):
                self.returncode = returncode
                self.stdout = stdout
                self.stderr = stderr
        
        result = AsyncResult(returncode, stdout, stderr)
        
        # Log completion
        completion_timestamp = datetime.utcnow().isoformat()
        logger.info(
            f"PENTEST_SCAN_COMPLETE | "
            f"user_id={user_id} | "
            f"target={scan_request.target} | "
            f"exit_code={result.returncode} | "
            f"success={result.returncode == 0} | "
            f"timestamp={completion_timestamp}"
        )
        
        return ScanResponse(
            success=result.returncode == 0,
            output=result.stdout,
            error=result.stderr if result.stderr else None,
            tool="dirb",
            target=scan_request.target
        )
        
    except subprocess.TimeoutExpired:
        logger.warning(
            f"PENTEST_SCAN_TIMEOUT | "
            f"user_id={user_id} | "
            f"target={scan_request.target} | "
            f"timestamp={datetime.utcnow().isoformat()}"
        )
        raise HTTPException(
            status_code=status.HTTP_408_REQUEST_TIMEOUT,
            detail="Scan operation timed out after 10 minutes"
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(
            f"PENTEST_SCAN_ERROR | "
            f"user_id={user_id} | "
            f"target={scan_request.target} | "
            f"error={str(e)} | "
            f"timestamp={datetime.utcnow().isoformat()}",
            exc_info=True
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to execute scan: {str(e)}"
        )
