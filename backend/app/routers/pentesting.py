# backend/app/routers/pentesting.py
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel
from typing import List, Optional
import asyncio
import shutil
import re
import ipaddress
from urllib.parse import urlparse
from app.auth import verify_firebase_token

router = APIRouter(prefix="/pentest", tags=["pentest"])

class ScanRequest(BaseModel):
    target: str
    options: List[str] = []  # Frontend sends array, not string


def find_tool_command(tool_name: str) -> list:
    """
    Return an executable command list for the tool.
    If the native tool is available (shutil.which), return [tool_name].
    Otherwise, try to run via WSL: ['wsl', tool_name]
    """
    if shutil.which(tool_name):
        return [tool_name]
    # fallback to WSL if present
    # Note: this assumes 'wsl' is available on Windows and distro installed.
    if shutil.which("wsl"):
        return ["wsl", tool_name]
    # no tool available natively
    return []


async def run_cmd(cmd_list: list, timeout: int = 120) -> dict:
    """
    Run command using asyncio.create_subprocess_exec, return decoded output.
    """
    if not cmd_list:
        return {"error": "tool_not_found"}
    proc = await asyncio.create_subprocess_exec(
        *cmd_list,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )
    try:
        stdout_bytes, stderr_bytes = await asyncio.wait_for(proc.communicate(), timeout)
    except asyncio.TimeoutError:
        proc.kill()
        await proc.communicate()
        return {"error": "timeout"}
    stdout = stdout_bytes.decode("utf-8", errors="ignore") if stdout_bytes else ""
    stderr = stderr_bytes.decode("utf-8", errors="ignore") if stderr_bytes else ""
    return {"stdout": stdout, "stderr": stderr, "returncode": proc.returncode}


def extract_hostname_for_nikto(target_url: str) -> tuple[str, bool]:
    """
    Extract hostname and whether SSL is required from target_url.
    Returns (hostname, use_ssl)
    """
    parsed = urlparse(target_url if "://" in target_url else f"http://{target_url}")
    hostname = parsed.hostname
    use_ssl = parsed.scheme == "https"
    if not hostname:
        # maybe user passed plain IP/host without scheme
        hostname = target_url.split("/")[0]
        use_ssl = False
    return hostname, use_ssl


@router.post("/nmap")
async def run_nmap(scan_request: ScanRequest, user=Depends(verify_firebase_token)):
    # build command
    base = find_tool_command("nmap")
    if not base:
        raise HTTPException(status_code=500, detail="nmap not found (native or wsl)")

    target = scan_request.target.strip()
    if not target:
        raise HTTPException(status_code=400, detail="target required")
    
    # Basic validation - reject private IPs
    try:
        ip = ipaddress.ip_address(target)
        if ip.is_private or ip.is_loopback or ip.is_link_local or ip.is_reserved:
            raise HTTPException(status_code=400, detail="Private/local IPs are not allowed")
    except ValueError:
        # Not an IP, assume it's a domain (basic check)
        if not re.match(r'^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$', target):
            raise HTTPException(status_code=400, detail="Invalid target format")
    except HTTPException:
        # Re-raise HTTPException (for private IP errors) without catching
        raise

    # Sanitize options - only allow safe characters
    sanitized_options = []
    for opt in (scan_request.options or []):
        opt = opt.strip()
        if opt and re.match(r'^[a-zA-Z0-9\-_.,:/=]+$', opt):
            sanitized_options.append(opt)

    cmd = base + sanitized_options + [target]
    res = await run_cmd(cmd, timeout=180)
    if res.get("error"):
        raise HTTPException(status_code=500, detail=res["error"])
    
    # Return format expected by frontend
    return {
        "success": res["returncode"] == 0,
        "output": res["stdout"],
        "error": res["stderr"] if res["stderr"] else None,
        "tool": "nmap",
        "target": target
    }


@router.post("/nikto")
async def run_nikto(scan_request: ScanRequest, user=Depends(verify_firebase_token)):
    base = find_tool_command("nikto")
    if not base:
        raise HTTPException(status_code=500, detail="nikto not found (native or wsl)")

    target_url = scan_request.target.strip()
    if not target_url:
        raise HTTPException(status_code=400, detail="target required")
    
    # Validate URL format
    if not (target_url.startswith("http://") or target_url.startswith("https://")):
        raise HTTPException(status_code=400, detail="Target must be a valid URL starting with http:// or https://")

    hostname, use_ssl = extract_hostname_for_nikto(target_url)
    
    # Validate hostname (reject private IPs)
    try:
        ip = ipaddress.ip_address(hostname)
        if ip.is_private or ip.is_loopback or ip.is_link_local or ip.is_reserved:
            raise HTTPException(status_code=400, detail="Private/local IPs are not allowed")
    except ValueError:
        pass  # Not an IP, assume domain
    
    cmd = base + ["-h", hostname]
    # add -ssl for HTTPS
    if use_ssl:
        cmd.append("-ssl")
    
    # Sanitize options
    for opt in (scan_request.options or []):
        opt = opt.strip()
        if opt and re.match(r'^[a-zA-Z0-9\-_.,:/=]+$', opt):
            cmd.append(opt)

    res = await run_cmd(cmd, timeout=300)
    if res.get("error"):
        raise HTTPException(status_code=500, detail=res["error"])
    
    # Return format expected by frontend
    return {
        "success": res["returncode"] == 0,
        "output": res["stdout"],
        "error": res["stderr"] if res["stderr"] else None,
        "tool": "nikto",
        "target": target_url
    }


@router.post("/dirb")
async def run_dirb(scan_request: ScanRequest, user=Depends(verify_firebase_token)):
    base = find_tool_command("dirb")
    if not base:
        raise HTTPException(status_code=500, detail="dirb not found (native or wsl)")

    target = scan_request.target.strip()
    if not target:
        raise HTTPException(status_code=400, detail="target required")
    
    # Validate URL format
    if not (target.startswith("http://") or target.startswith("https://")):
        raise HTTPException(status_code=400, detail="Target must be a valid URL starting with http:// or https://")
    
    # Extract and validate hostname
    parsed = urlparse(target)
    hostname = parsed.hostname or target.split("/")[0]
    try:
        ip = ipaddress.ip_address(hostname)
        if ip.is_private or ip.is_loopback or ip.is_link_local or ip.is_reserved:
            raise HTTPException(status_code=400, detail="Private/local IPs are not allowed")
    except ValueError:
        pass  # Not an IP, assume domain

    cmd = base + [target]
    
    # Sanitize options
    for opt in (scan_request.options or []):
        opt = opt.strip()
        if opt and re.match(r'^[a-zA-Z0-9\-_.,:/=]+$', opt):
            cmd.append(opt)

    res = await run_cmd(cmd, timeout=300)
    if res.get("error"):
        raise HTTPException(status_code=500, detail=res["error"])
    
    # Return format expected by frontend
    return {
        "success": res["returncode"] == 0,
        "output": res["stdout"],
        "error": res["stderr"] if res["stderr"] else None,
        "tool": "dirb",
        "target": target
    }
